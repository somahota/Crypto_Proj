package crpto_proj;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidParameterSpecException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.Mac;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.digest.DigestUtils;
import static org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224;
import org.apache.commons.math3.distribution.LaplaceDistribution;

/**
 *
 * @author Soma
 */
public class Stats_ABC extends javax.swing.JFrame {

    /**
     * Creates new form Stats_ABC
     */
    public Stats_ABC() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jButton2 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));

        jButton2.setFont(new java.awt.Font("Times New Roman", 1, 24)); // NOI18N
        jButton2.setText("Allow Connection");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton1.setFont(new java.awt.Font("Times New Roman", 1, 24)); // NOI18N
        jButton1.setText("Common  Data");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton3.setFont(new java.awt.Font("Times New Roman", 1, 24)); // NOI18N
        jButton3.setText("Victim Count");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jButton4.setFont(new java.awt.Font("Times New Roman", 1, 24)); // NOI18N
        jButton4.setText("Mean Age");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jLabel4.setIcon(new javax.swing.ImageIcon("C:\\Users\\Soma\\Desktop\\Brown\\Crypto\\Proj\\key.png")); // NOI18N

        jPanel2.setBackground(new java.awt.Color(0, 255, 255));

        jLabel5.setBackground(new java.awt.Color(0, 204, 204));
        jLabel5.setFont(new java.awt.Font("Times New Roman", 3, 24)); // NOI18N
        jLabel5.setText(" ORG ABC");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 117, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(18, Short.MAX_VALUE))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButton2)
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, 280, Short.MAX_VALUE)
                    .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 195, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()
                        .addGap(175, 175, 175)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 195, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 195, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 45, Short.MAX_VALUE)
                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(2, 2, 2)
                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(245, 245, 245)
                        .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(jPanel1Layout.createSequentialGroup()
                                .addGap(39, 39, 39)
                                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(29, 29, 29)
                                .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 48, Short.MAX_VALUE)
                                .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addContainerGap())))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(25, 25, 25))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(29, 29, 29)
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>                        

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:
        try
        {

             ArrayList<XYZ> serverEntries = Server.getEntries("ABC.txt");

            ArrayList<XYZ> clientEntries = Client.getEntries("XYZ.txt");

            ArrayList<XYZ> serverEncryptedEntries = new ArrayList<XYZ>();

            for (XYZ e : serverEntries)
            {
               serverEncryptedEntries.add(Server.encryptAndHmac(e));

            }

           ArrayList<XYZ> matches= Client.checkForCommonEntries(clientEntries,serverEncryptedEntries);

           Client.getCommonEntriesAndTheirData(matches,clientEntries);


        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        
        
    }                                        

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:
        try
        {
            ServerSocket ser = new ServerSocket(1234);
            Socket s1 = ser.accept();
            jLabel1.setText("Request for Common Data");
            //ser.close();
        }catch(Exception ex){}
        try
        {
            ServerSocket ser = new ServerSocket(2245);
            Socket s2 = ser.accept();
            jLabel2.setText("Request for Victim Count");
            //ser.close();
        }catch(Exception ex){}
        try
        {
            ServerSocket ser = new ServerSocket(3356);
            Socket s3 = ser.accept();
            jLabel3.setText("Request for Mean Age");
            ser.close();
            
        }catch(Exception ex){}
    }                                        

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        try {
            // TODO add your handling code here:
            System.out.println("Laplace Mean is:"+ Mean());
        } catch (IOException ex) {
            Logger.getLogger(Stats_ABC.class.getName()).log(Level.SEVERE, null, ex);
        }
    }                                        

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        try {
            // TODO add your handling code here:
            System.out.println("Laplace count is:"+ Count("human_data.txt"));
        } catch (IOException ex) {
            Logger.getLogger(Stats_ABC.class.getName()).log(Level.SEVERE, null, ex);
        }
        
    }                                        

    public static double Count(String filename) throws IOException {
    InputStream is = new BufferedInputStream(new FileInputStream(filename));
    try {
        byte[] c = new byte[1024];
        int count = 0;
        int readChars = 0;
        boolean empty = true;
        while ((readChars = is.read(c)) != -1) {
            empty = false;
            for (int i = 0; i < readChars; ++i) {
                if (c[i] == '\n') {
                    ++count;
                }
            }
        }
        System.out.println("True count:"+count);
        LaplaceDistribution ld = new LaplaceDistribution(0, 1 / 0.9);
        double noise = ld.sample();
        //return (count == 0 && !empty) ? 1 : count;
        double final_count = count +noise;
        String dp_count = String.valueOf(final_count);
        try{      
        Socket so2=new Socket("localhost",2222);  
        DataOutputStream dout=new DataOutputStream(so2.getOutputStream());  
        dout.writeUTF(dp_count);  
        dout.flush();  
        dout.close();  
        so2.close();  
        }catch(Exception e){System.out.println(e);}  
        return final_count;
        } finally {
        is.close();
    }
}
    public static double Mean() throws IOException {
        File file = new File("human_data.txt");   
    Scanner scanner = new Scanner(file);
    List<Integer> integers = new ArrayList<>();
    while (scanner.hasNext()) {
    if (scanner.hasNextInt()) {
        integers.add(scanner.nextInt());
    } 
    else {
        scanner.next();
    }
}
System.out.println(integers);
int sum=0;
int mean = 0;
for (int i=0; i<6; i++)
{
    sum = sum +integers.get(i);
}
int true_mean = sum/6;
System.out.println("True mean:"+true_mean);
        
        LaplaceDistribution ld = new LaplaceDistribution(0, 6/ 0.9);
        double noise = ld.sample();
        double final_sum = sum +noise;
        double final_mean = final_sum/6;
        String dp_mean = String.valueOf(final_mean);
        try{      
        Socket so3=new Socket("localhost",3333);  
        DataOutputStream dout=new DataOutputStream(so3.getOutputStream());  
        dout.writeUTF(dp_mean);  
        dout.flush();  
        dout.close();  
        so3.close();  
        }catch(Exception e){System.out.println(e);}  
        return final_mean;
        
    } 
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Stats_ABC.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Stats_ABC.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Stats_ABC.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Stats_ABC.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Stats_ABC().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify                     
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    // End of variables declaration                   
}
class ABC {
    
    static String getName(String line) throws IOException
    {
        String[] entry = line.split(" ");

        String name = (entry[0]);

        return name;
    }

    /**
     * Returns the output of the SHA-2 hash function over the input
     * @param input
     * @return
     */
    static String sha2_1Hash(String input)
    {
        String digest = org.apache.commons.codec.digest.DigestUtils.sha256Hex(input);

        return digest;
    }

    /**
     * Returns the output of the MD5 hash function over the input
     * @param input
     * @return
     */
    static String sha2_2Hash(String input)
    {
        String digest = org.apache.commons.codec.digest.DigestUtils.sha256Hex(input);

        return digest;

    }

}

/**
 * Represents the server participating in the private set intersection scheme
 * The server hash a list of entries, each entry includes a name and some data
 * The server wants to inform the client about entries they have in common and their associated data,
 * but without revealing to the client any entries outside the intersection
 */
class Server extends ABC
{
    /**
     * Returns the data associated with an entry
     * @param line
     * @return
     * @throws IOException
     */
    static String getAssociatedData(String line) throws IOException
    {
        String[] entry = line.split(" ");
        //System.out.println("entry: "+entry[1]);

        String associatedData = entry[1];

        return associatedData;
    }

    /**
     * Returns an arraylist of type XYZ with all the entries included
     * in the input file
     * @param filename
     * @return
     * @throws IOException
     */
    static ArrayList<XYZ> getEntries(String filename) throws IOException
    {
        

        try
        {
            //ClassLoader classloader = Thread.currentThread().getContextClassLoader();

            //InputStream is = null;
            //is= classloader.getResourceAsStream(filename);
            //System.out.println("3");
            //br = new BufferedReader(new InputStreamReader(is));
            Path path = Paths.get(filename);
          
            BufferedReader br = Files.newBufferedReader(path, Charset.defaultCharset());
            ArrayList<XYZ> entries = new ArrayList<XYZ>();

            String line;
           while ((line = br.readLine()) != null)
            {
                //System.out.println("Buffered not null");
                String name = getName(line);

                String sha2_2 = sha2_2Hash(name);

                String sha2_1 = sha2_1Hash(name);

                String data = getAssociatedData(line);

                XYZ entry = new XYZ(sha2_2, sha2_1,data);

                entries.add(entry);
            }
            return entries;
        }
        catch (FileNotFoundException e)
        {
            System.out.println("File not found");
        }
        //finally
        //{
          //br.close();
        //}
        return null;
    }

    /**
     * Encrypts the associated data of the input entry with AES-128 in CBC mode
     * using the output of the MD5 hash function over the name of the entry as the key
     * Computes the H-MAC over the encrypted associated data using the output of the
     * MD5 hash function over the name of the entry as the key
     * @param entry
     * @return
     */
    static XYZ encryptAndHmac(XYZ entry)
    {
        try
        {
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

            IvParameterSpec spec = cipher.getParameters().getParameterSpec(IvParameterSpec.class);

            byte[] initializationVector = spec.getIV();

            IvParameterSpec iv = new IvParameterSpec(initializationVector);

            String sha2_2name = entry.getSha2_2();

            byte[] aesKey = sha2_2name.substring(0,sha2_2name.length()/2).getBytes("UTF-8"); //key

            byte[] str = entry.getData().getBytes("UTF-8");   //plaintext

            SecretKeySpec key = new SecretKeySpec(aesKey, "AES");

            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            byte[] ciphertext = cipher.doFinal(str);

            byte[] encryptedByteValue = java.util.Base64.getEncoder().encode(ciphertext);
            

            String encryptedValue = new String(encryptedByteValue);

            entry.setIV(initializationVector);

            entry.setData(encryptedValue);

            byte[] hmac = computeHmac(entry);

            entry.setHmac(hmac);

            entry.setName(null);

            return entry;
        }
        catch (NoSuchAlgorithmException e)
        {
            System.out.println("Invalid encryption algorithm");
        }
        catch (NoSuchPaddingException e)
        {
            System.out.println("Invalid padding selection");
        }
        catch (InvalidParameterSpecException e)
        {
            System.out.println("Invalid parameters selected");
        }
        catch (InvalidAlgorithmParameterException e)
        {
            System.out.println("Invalid algorithm parameters");
        }
        catch (InvalidKeyException e)
        {
            System.out.println("Invalid key 1");
        }
        catch (IllegalBlockSizeException e)
        {
            System.out.println("Illegal block size");
        }
        catch (BadPaddingException e)
        {
            System.out.println("Invalid padding specified");
        }
        catch (UnsupportedEncodingException e)
        {
            System.out.println("The encoding is not supported");
        }
        return null;
    }

    /**
     * Computes the H-MAC over the encrypted associated data of the input entry
     * using the output of the MD5 hash function over the name of the entry as the key
     * @param encryptedXYZ
     * @return
     */
    static byte[] computeHmac(XYZ encryptedXYZ)
    {
        try
        {
            Mac mac = Mac.getInstance("HmacSHA256");

            byte[] hmacKey = (encryptedXYZ.getSha2_2()).getBytes();  //get key

            byte[] dataToHmac = (encryptedXYZ.getData()).getBytes();

            SecretKeySpec signingKey = new SecretKeySpec(hmacKey, "HmacSHA256");

            mac.init(signingKey);

            byte[] rawHmac = mac.doFinal(dataToHmac);

            encryptedXYZ.setHmac(rawHmac);

            return rawHmac;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return null;
    }
}

/**
 * Represents the client participating in the private set intersection shceme
 * The client hash a list of entries and wishes to learn the intersection of these entries
 * with the entries stored in a server as well as the data associated with each common entry
 * but without revealing to the server any entries outside the intersection
 */
class Client extends ABC
{
    static ArrayList<XYZ> getEntries(String filename) throws IOException
    {
        //BufferedReader br = null;

        try
        {
           // ClassLoader classloader = Thread.currentThread().getContextClassLoader();

            //InputStream is = classloader.getResourceAsStream(filename);

            //br = new BufferedReader(new InputStreamReader(is));
            Path path = Paths.get(filename);
            //System.out.println("7");
            BufferedReader br = Files.newBufferedReader(path, Charset.defaultCharset());

            ArrayList<XYZ> entries = new ArrayList<XYZ>();

            String line;

            while ((line = br.readLine()) != null)
            {
                String name = getName(line);

                XYZ entry = new XYZ(name);

                entries.add(entry);
            }
            return entries;
        }
        catch (FileNotFoundException e)
        {
            System.out.println("File not found");
        }
        //finally
        //{
          //  br.close();
        //}
        return null;
    }

    /**
     * Returns an arraylist with the entries included in the intersection of two sets
     * based on their SHA-2 fields
     * @param clientEntries
     * @param serverEntries
     * @return
     * @throws IOException
     */
    static ArrayList<XYZ> checkForCommonEntries(ArrayList<XYZ> clientEntries, ArrayList<XYZ> serverEntries) throws IOException
    {
        try
        {
            ArrayList<XYZ> commonEntries = new ArrayList<XYZ>();

            for (XYZ bobEntry : clientEntries)
            {
                bobEntry.setSha2_1(sha2_1Hash(bobEntry.getName()));
            }

            for (XYZ bobEntry : clientEntries)
            {
                for (XYZ serverEntry : serverEntries)
                {
                    if (Objects.equals(bobEntry.getSha2_1(),serverEntry.getSha2_1()))
                    {
                        commonEntries.add(serverEntry);
                    }
                }
            }
            return commonEntries;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Decrypts the associated data of the input entry using AES-128 in CBC mode
     * and the MD5 input parameter as the key
     * @param encryptedEntry
     * @param sha_2
     * @return
     */
    static byte[] decryptEntry(XYZ encryptedEntry, String sha2_2)
    {
        try
        {
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

            String encryptedData = encryptedEntry.getData();

            IvParameterSpec iv = new IvParameterSpec(encryptedEntry.getIV());

            byte[] aesDecKey = (sha2_2).substring(0,sha2_2.length()/2).getBytes("UTF-8"); //key

            byte[] aesDecInput = java.util.Base64.getDecoder().decode(encryptedData.getBytes("UTF-8"));

            SecretKeySpec key = new SecretKeySpec(aesDecKey, "AES");

            cipher.init(Cipher.DECRYPT_MODE, key, iv);

            byte[] plaintext = cipher.doFinal(aesDecInput);

            return plaintext;

        }
        catch (NoSuchAlgorithmException e)
        {
            System.out.println("Invalid encryption algorithm");
        }
        catch (NoSuchPaddingException e)
        {
            System.out.println("Invalid padding selection");
        }
        catch (InvalidAlgorithmParameterException e)
        {
            System.out.println("Invalid algorithm parameters");
        }
        catch (InvalidKeyException e)
        {
            System.out.println("Invalid key 2");
        }
        catch (IllegalBlockSizeException e)
        {
            System.out.println("Illegal block size");
        }
        catch (BadPaddingException e)
        {
            System.out.println("Invalid padding specified");
        }
        catch (UnsupportedEncodingException e)
        {
            System.out.println("The encoding is not supported");
        }
        return null;
    }

    /**
     * Verifying the HMAC over the encrypted data of the input entry using the
     * sha_2 input parameter as the key
     * @param encryptedEntry
     * @param sha2_2
     * @return
     */
    static boolean verifyMac(XYZ encryptedEntry, String sha2_2)
    {
        try
        {
            Mac mac = Mac.getInstance("HmacSHA256");

            byte[] hmacKey = (sha2_2).getBytes(); // get hmac key , bob's sha_2 output

            byte[] hmacInput = (encryptedEntry.getData().getBytes());

            SecretKeySpec key = new SecretKeySpec(hmacKey, "HmacSHA256");

            mac.init(key);

            byte[] rawHmac = mac.doFinal(hmacInput);  //calculate hmac

            if (Arrays.equals(encryptedEntry.getHmac(), rawHmac))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        catch (NoSuchAlgorithmException e)
        {
            System.out.println("Invalid encryption algorithm");
        }
        catch (InvalidKeyException e)
        {
            System.out.println("Invalid key 3");
        }
        return false;
    }

    /**
     * Prints the entries included in the intersections of two sets and their associated data
     * @param matches
     * @param bobEntries
     */
    static protected void getCommonEntriesAndTheirData(ArrayList<XYZ> matches, ArrayList<XYZ> bobEntries) throws IOException
    {
        for (XYZ entry : bobEntries)
        {
            for (XYZ encryptedEntry : matches)
            {
                if (Client.sha2_1Hash(entry.getName()).equals(encryptedEntry.getSha2_1()))
                {
                    if (Client.verifyMac(encryptedEntry, Client.sha2_2Hash(entry.getName())))
                    {
                        

                        byte[] decryptedData = Client.decryptEntry(encryptedEntry, Client.sha2_2Hash(entry.getName()));

                        System.out.println(entry.getName() + "'s associated data is: " + new String(decryptedData));
                        
                        try{
                         ServerSocket socket = new ServerSocket(1111);
                        Socket s = socket.accept();
                        DataOutputStream dout=new DataOutputStream(s.getOutputStream());  
                        dout.writeUTF(entry.getName() + "'s associated data is: " + new String(decryptedData));  
                        dout.flush();  
                        dout.close();  
                        s.close();  
                        }catch(Exception e){System.out.println(e);}   
                    }
                }
            }
        }
    }
}
class XYZ {
    private String name;

    private String sha2_2;

    private String sha2_1;

    private byte[] IV;

    private String data;

    private byte[] hmac;


    /**
     * Initialises a new Entry object and sets the name field
     * @param name
     */
    XYZ(String name)
    {
        this.name=name;
    }

    /**
     * Initialises a new Entry object and sets the sha2 and data fields
     * @param sha2_2
     * @param sha2_1
     * @param data
 */

    XYZ(String sha2_2, String sha2_1, String data) {
        this.sha2_2=sha2_2;
        this.sha2_1=sha2_1;
        this.data = data;
        
    }
    

    /**
     * Returns the name of the Entry
     * @return
     */
    public String getName()
    {
        return name;
    }

    /**
     * Sets the name of the Entry
     * @param name
     */
    public void setName(String name)
    {
        this.name = name;
    }

    /**
     * Returns the sha_2 field of the Entry
     * @return
     */
   protected String getSha2_2()
    {
        return sha2_2;
    }

    /**
     * Sets the sha2_2 field of the Entry
     * @param sha2_2
     */
    protected void setSha2(String sha2_2)
    {
        this.sha2_2 = sha2_2;
    }

    /**
     * Returns the sha2 field of the Entry
     * @return
     */
    protected String getSha2_1()
    {
        return sha2_1;
    }
    
    /**
     * Sets the sha1 field of the Entry
     * @return
     */
    protected void setSha2_1(String sha2_1)
    {
        this.sha2_1 = sha2_1;
    }

    /**
     * Returns a byte array with the the IV field of the Entry
     * @return
     */
    protected byte[] getIV()
    {
        return IV;
    }

    /**
     * Sets the IV field of the Entry
     * @param IV
     */
    protected void setIV(byte[] IV)
    {
        this.IV = IV;
    }

    /**
     * Returns the data associated with this Entry
     * @return
     */
    public String getData()
    {
        return data;
    }

    /**
     * Sets the data field of this Entry
     * @param data
     */
    protected void setData(String data)
    {
        this.data = data;
    }

    /**
     * Returns a byte array with the hmac of this Entry
     * @return
     */
    protected byte[] getHmac()
    {
        return hmac;
    }

    /**
     * Sets the hmac field of this Entry
     * @param hmac
     */
    protected void setHmac(byte[] hmac)
    {
        this.hmac = hmac;
    }
}

